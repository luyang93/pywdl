from pywdl.antlr.WdlParser import WdlParser
from pywdl.antlr.WdlParserVisitor import WdlParserVisitor
from antlr4.tree.Tree import TerminalNodeImpl
from toil.wdl.wdl_types import (
    WDLStringType,
    WDLIntType,
    WDLFloatType,
    WDLBooleanType,
    WDLFileType,
    WDLArrayType,
    WDLPairType,
    WDLMapType
)


class AntlrToWorkflow(WdlParserVisitor):
    """
    Convert the WDL syntax trees generated by Antlr4 to Python objects.
    """
    def __init__(self, ):
        # holds workflow structure from WDL workflow objects
        self.workflows_dictionary = dict()

        # holds task skeletons from WDL task objects
        self.tasks_dictionary = dict()

    def visitDocument(self, ctx: WdlParser.DocumentContext):
        """
        Top level tree. Contains `version` followed by any number of `document_element`.
        """
        self.visitVersion(ctx.version())
        for element in ctx.document_element():
            self.visitDocument_element(element)

    def visitVersion(self, ctx: WdlParser.VersionContext):
        assert str(ctx.RELEASE_VERSION()) in ('1.0', 'development'), \
            f'Unknown version: {str(ctx.RELEASE_VERSION())}.'

    def visitDocument_element(self, ctx: WdlParser.Document_elementContext):
        """
        A child of 'import_doc', 'struct', 'workflow', or 'task'.
        """
        # TODO: add support for imports.
        assert isinstance(ctx.children[0], (WdlParser.WorkflowContext,
                                            WdlParser.TaskContext,
                                            WdlParser.ScatterContext)), \
            'Import is not supported.'

        return self.visit(ctx.children[0])

    def visitWorkflow(self, ctx: WdlParser.WorkflowContext):
        """
        Contains an 'identifier' and an array of `workflow_element`.
        """
        # TODO: store this to self.workflows_dictionary

        identifier = ctx.Identifier().getText()
        print(f'Visiting workflow: {identifier}')

        for element in ctx.workflow_element():
            self.visit(element)

    def visitWorkflow_input(self, ctx: WdlParser.Workflow_inputContext):
        """
        Contains an array of 'any_decls', which can be an unbounded or bounded declaration.

        Example:
            input {
              String in_str = "twenty"
              Int in_int
            }
        """
        for index in range(ctx.getChildCount() - 3):  # skip 'input', '{', and '}'
            name, decl = self.visitAny_decls(ctx.any_decls(i=index))
            self.workflows_dictionary.setdefault(name, dict())['wf_declarations'] = decl

    def visitUnbound_decls(self, ctx: WdlParser.Unbound_declsContext):
        """
        Contains an unbounded input declaration. E.g.: `String in_str`.
        """
        name = ctx.Identifier().getText()
        type_ = self.visitWdl_type(ctx.wdl_type())
        return name, dict({'name': name, 'type': type_, 'value': None})

    def visitBound_decls(self, ctx: WdlParser.Bound_declsContext):
        """
        Contains a bounded input declaration. E.g.: `String in_str = "some string"`.
        """
        name = ctx.Identifier().getText()
        type_ = self.visitWdl_type(ctx.wdl_type())
        expr = super().visitChildren(ctx.expr())
        # TODO: figure out expr_infix.
        print('expr:', expr)

        return name, dict({'name': name, 'type': type_, 'value': expr})

    def visitWdl_type(self, ctx: WdlParser.Wdl_typeContext):
        type_: WdlParser.Type_baseContext = ctx.type_base().children[0]
        optional = ctx.OPTIONAL() is not None

        # base level
        if isinstance(type_, TerminalNodeImpl):
            if type_.getText() == 'String':
                return WDLStringType(optional)
            elif type_.getText() == 'Int':
                return WDLIntType(optional)
            elif type_.getText() == 'Float':
                return WDLFloatType(optional)
            elif type_.getText() == 'Boolean':
                return WDLBooleanType(optional)
            elif type_.getText() == 'File':
                return WDLFileType(optional)
            else:
                raise RuntimeError(f'Unsupported primitive type: {type_.getText()}')
        # recursively parse compound types
        elif isinstance(type_, WdlParser.Array_typeContext):
            return WDLArrayType(self.visitWdl_type(type_.wdl_type()), optional)
        elif isinstance(type_, WdlParser.Pair_typeContext):
            return WDLPairType(
                left=self.visitWdl_type(type_.wdl_type(0)),
                right=self.visitWdl_type(type_.wdl_type(1)),
                optional=optional)
        elif isinstance(type_, WdlParser.Map_typeContext):
            return WDLMapType(
                key=self.visitWdl_type(type_.wdl_type(0)),
                value=self.visitWdl_type(type_.wdl_type(1)),
                optional=optional)
        else:
            raise RuntimeError(f'Unsupported type: {type_.getText()}')

    def visitString(self, ctx: WdlParser.StringContext):
        """
        Contains " (quotation mark), string_part, and " (quotation mark). Returns
        the `string_part` as a Python string.
        """
        return ctx.string_part().getText()

    def visitNumber(self, ctx: WdlParser.NumberContext):
        return 'number'

    def visitTask(self, ctx: WdlParser.TaskContext):
        return super().visitChildren(ctx)

    def visitScatter(self, ctx: WdlParser.ScatterContext):
        return super().visitChildren(ctx)
