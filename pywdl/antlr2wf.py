from collections import OrderedDict  # TODO: switch to dict.

from pywdl.antlr.WdlParser import WdlParser
from pywdl.antlr.WdlParserVisitor import WdlParserVisitor
from antlr4.tree.Tree import TerminalNodeImpl
from pywdl.types import (
    WDLStringType,
    WDLIntType,
    WDLFloatType,
    WDLBooleanType,
    WDLFileType,
    WDLArrayType,
    WDLPairType,
    WDLMapType
)


class AntlrToWorkflow(WdlParserVisitor):
    """
    Convert the WDL syntax trees generated by Antlr4 to Python objects.
    """

    primitive_types = {
        'String': WDLStringType,
        'Int': WDLIntType,
        'Float': WDLFloatType,
        'Boolean': WDLBooleanType,
        'File': WDLFileType,
        'Directory': None,  # to be implemented.
    }

    def __init__(self, ):
        # holds workflow structure from WDL workflow objects
        self.workflows_dictionary = dict()

        # holds task skeletons from WDL task objects
        self.tasks_dictionary = dict()

    def visitDocument(self, ctx: WdlParser.DocumentContext):
        """
        Root of tree. Contains `version` followed by any number of `document_element`s.
        """
        self.visitVersion(ctx.version())
        for element in ctx.document_element():
            self.visitDocument_element(element)

    def visitVersion(self, ctx: WdlParser.VersionContext):
        assert str(ctx.RELEASE_VERSION()) in ('1.0', 'development'), \
            f'Unsupported version: {str(ctx.RELEASE_VERSION())}.'

    def visitDocument_element(self, ctx: WdlParser.Document_elementContext):
        """
        Contains one of the following: 'import_doc', 'struct', 'workflow', or 'task'.
        """
        # TODO: add support for imports.
        assert isinstance(ctx.children[0], (WdlParser.WorkflowContext,
                                            WdlParser.TaskContext,
                                            WdlParser.ScatterContext)), \
            'Import is not supported.'

        return self.visit(ctx.children[0])

    # Workflow section

    def visitWorkflow(self, ctx: WdlParser.WorkflowContext):
        """
        Contains an 'identifier' and an array of `workflow_element`s.
        """
        identifier = ctx.Identifier().getText()
        self.workflows_dictionary.setdefault(identifier, OrderedDict())

        print(f'Visiting workflow: {identifier}')
        for element in ctx.workflow_element():
            section = element.children[0]
            if isinstance(section, WdlParser.Workflow_inputContext):
                self.workflows_dictionary[identifier]['wf_declarations'] = self.visitWorkflow_input(section)
            elif isinstance(section, WdlParser.Inner_workflow_elementContext):
                # TODO
                pass
            elif isinstance(section, WdlParser.Workflow_outputContext):
                # FIXME: Seems like this portion is not supported in Toil?
                self.workflows_dictionary[identifier]['wf_outputs'] = self.visitWorkflow_output(section)
                pass
            else:
                raise NotImplementedError

    def visitWorkflow_input(self, ctx: WdlParser.Workflow_inputContext):
        """
        Contains an array of 'any_decls', which can be unbounded or bounded declarations.

        Example:
            input {
              String in_str = "twenty"
              Int in_int
            }

        Returns an array of tuples=(name, decl).
        """
        decls = []
        for index in range(ctx.getChildCount() - 3):  # skip 'input', '{', and '}'
            name, decl = self.visitAny_decls(ctx.any_decls(i=index))
            decls.append((name, decl))
        return decls

    def visitWorkflow_output(self, ctx: WdlParser.Workflow_outputContext):
        """
        Contains an array of 'bound_decls' (unbound_decls not allowed).

        Example:
            output {
              String out_str = read_string(stdout())
            }

        Returns an array of tuples=(name, decl).
        """
        decls = []
        for index in range(ctx.getChildCount() - 3):  # skip 'output', '{', and '}'
            name, decl = self.visitBound_decls(ctx.bound_decls(i=index))
            decls.append((name, decl))
        return decls

    def visitInner_workflow_element(self, ctx: WdlParser.Inner_workflow_elementContext):
        """
        """
        # bound_decls (e.g.: declarations declared outside of input section)
        # TODO

        # call
        # TODO

        # scatter
        # TODO

        # conditional
        # TODO

        pass

    def visitCall(self, ctx: WdlParser.CallContext):
        """

        """
        return super().visitChildren(ctx)

    def visitScatter(self, ctx: WdlParser.ScatterContext):
        """

        """
        return super().visitChildren(ctx)

    def visitConditional(self, ctx: WdlParser.ConditionalContext):
        """

        """
        pass

    # Task section

    def visitTask(self, ctx: WdlParser.TaskContext):
        print('visitTask')
        # return super().visitChildren(ctx)

    #

    # Shared

    def visitUnbound_decls(self, ctx: WdlParser.Unbound_declsContext):
        """
        Contains an unbounded input declaration. E.g.: `String in_str`.

        Returns a tuple=(`name`, dict={`name`, `type`, `value`}), where `value` is None.
        """
        name = ctx.Identifier().getText()
        type_ = self.visitWdl_type(ctx.wdl_type())
        return name, OrderedDict({'name': name, 'type': type_, 'value': None})

    def visitBound_decls(self, ctx: WdlParser.Bound_declsContext):
        """
        Contains a bounded input declaration. E.g.: `String in_str = "some string"`.

        Returns a tuple=(`name`, dict={`name`, `type`, `value`}).
        """
        name = ctx.Identifier().getText()
        type_ = self.visitWdl_type(ctx.wdl_type())
        expr = self.visitChildren(ctx.expr())

        # if isinstance(type_, WDLBooleanType):
        #     assert expr in ('true', 'false'), 'Parsed boolean ({}) must be expressed as "true" or "false".'
        #     expr = expr.capitalize()

        return name, OrderedDict({'name': name, 'type': type_, 'value': expr})

    def visitWdl_type(self, ctx: WdlParser.Wdl_typeContext):
        """
        Returns a WDLType instance.
        """
        var_type: WdlParser.Type_baseContext = ctx.type_base().children[0]
        optional = ctx.OPTIONAL() is not None

        # base level
        if isinstance(var_type, TerminalNodeImpl):
            type_ = self.primitive_types.get(var_type.getText())
            if type_:
                return type_(optional=optional)
            else:
                raise RuntimeError(f'Unsupported primitive type: {var_type.getText()}')
        # recursively visit compound types
        elif isinstance(var_type, WdlParser.Array_typeContext):
            # Array[element]
            return WDLArrayType(element=self.visitWdl_type(var_type.wdl_type()), optional=optional)
        elif isinstance(var_type, WdlParser.Pair_typeContext):
            # Pair[left, right]
            return WDLPairType(
                left=self.visitWdl_type(var_type.wdl_type(0)), right=self.visitWdl_type(var_type.wdl_type(1)),
                optional=optional)
        elif isinstance(var_type, WdlParser.Map_typeContext):
            # Map[left, right]
            return WDLMapType(
                key=self.visitWdl_type(var_type.wdl_type(0)), value=self.visitWdl_type(var_type.wdl_type(1)),
                optional=optional)
        else:
            raise RuntimeError(f'Unsupported type: {var_type.getText()}')

    def visitPrimitive_literal(self, ctx: WdlParser.Primitive_literalContext):
        """
        Returns the primitive literal as a string.
        """
        if isinstance(ctx.children[0], (TerminalNodeImpl,
                                        WdlParser.StringContext,
                                        WdlParser.NumberContext)):
            return ctx.children[0].getText()
        else:
            raise RuntimeError(f'Primitive literal has unknown child: {type(ctx.children[0])}.')

    def visitLand(self, ctx: WdlParser.LandContext):
        """
        Logical AND infix.
        """
        lhs = self.visitInfix1(ctx.expr_infix1())
        rhs = self.visitInfix2(ctx.expr_infix2())
        return f'{lhs} and {rhs}'

    def visitLor(self, ctx: WdlParser.LorContext):
        """
        Logical OR infix.
        """
        lhs = self.visitInfix0(ctx.expr_infix0())
        if isinstance(ctx.expr_infix1(), WdlParser.LandContext):
            rhs = self.visitLand(ctx.expr_infix1())
        else:
            rhs = self.visitInfix1(ctx.expr_infix1())
        return f'{lhs} or {rhs}'

    def visitExpression_group(self, ctx: WdlParser.Expression_groupContext):
        """
        Contains: '(', `expr`, and ')'
        """
        return f'({self.visitExpr(ctx.expr())})'
